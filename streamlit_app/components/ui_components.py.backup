# streamlit_app/components/ui_components.py

import streamlit as st
import os
import base64
from io import BytesIO
from PIL import Image
from app.config import RAW_DATA_PATH
from app.pipeline.retriever import edit_answer, enhanced_rag_query
from streamlit_app.backend_logic import process_uploaded_file, delete_source

def upload_widget(indexer):
    """Disegna il widget di upload e gestisce l'indicizzazione in modo sicuro."""
    st.header("Carica un Nuovo Documento")
    uploaded_file = st.file_uploader(
        "Scegli un file PDF", type="pdf", label_visibility="collapsed"
    )

    if uploaded_file:
        # --- INIZIO DELLA CORREZIONE ---
        
        # Creiamo una chiave unica per questo specifico file caricato.
        # Usare nome + dimensione lo rende robusto anche se si ricarica lo stesso file.
        upload_key = f"processed_{uploaded_file.name}_{uploaded_file.size}"

        # Eseguiamo l'indicizzazione SOLO SE non abbiamo gi√† processato questo file
        # nella sessione corrente.
        if upload_key not in st.session_state:
            with st.spinner(f"Indicizzazione di '{uploaded_file.name}' in corso..."):
                success, message = process_uploaded_file(uploaded_file, indexer)
            
            if success:
                st.success(message)
                # Marchiamo il file come processato nella sessione.
                st.session_state[upload_key] = True
                # Ora possiamo fare il rerun in sicurezza per aggiornare la UI.
                st.rerun()
            else:
                st.error(message)
                # Marchiamo anche i fallimenti per non riprovare all'infinito.
                st.session_state[upload_key] = True
        
        # --- FINE DELLA CORREZIONE ---


def source_selector_widget():
    """Disegna il widget per selezionare ed eliminare le fonti."""
    st.header("Gestisci e Seleziona le Fonti")
    
    if not os.path.exists(RAW_DATA_PATH) or not os.listdir(RAW_DATA_PATH):
        st.info("Nessun documento trovato. Caricane uno per iniziare.")
        return []

    available_files = sorted([f for f in os.listdir(RAW_DATA_PATH) if f.endswith(".pdf")])
    
    if 'selected_files' not in st.session_state:
        st.session_state.selected_files = available_files

    selected_now = st.multiselect(
        "Seleziona i documenti per la chat:", 
        options=available_files, 
        default=st.session_state.selected_files
    )
    st.session_state.selected_files = selected_now

    st.markdown("---")
    with st.expander("üóëÔ∏è Elimina documenti"):
        for file in available_files:
            if st.button(f"Elimina '{file}'", key=f"del_{file}"):
                if file in st.session_state.selected_files:
                    st.session_state.selected_files.remove(file)
                with st.spinner(f"Eliminazione di '{file}' in corso..."):
                    success, message = delete_source(file)
                if success:
                    st.success(message)
                    st.rerun()
                else:
                    st.error(message)
    
    return selected_now

def chat_interface_widget(selected_sources: list[str]):
    """Disegna l'interfaccia di chat."""
    st.header("Chatta con le Fonti Selezionate")

    if not selected_sources:
        st.warning("Seleziona almeno una fonte per avviare la chat.")
        return

    # Logica per creare/caricare la catena RAG
    if st.session_state.get('last_selected_sources') != selected_sources:
        st.session_state.last_selected_sources = selected_sources


    # Inizializzazione e visualizzazione messaggi
    if "messages" not in st.session_state:
        st.session_state.messages = [{"role": "assistant", "content": "Ciao! Fai una domanda sulle fonti selezionate."}]

    for msg in st.session_state.messages:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])

    # Input utente e risposta del bot
    if prompt := st.chat_input("Fai la tua domanda..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)

        with st.chat_message("assistant"):
            with st.spinner("Sto pensando..."):
                response = enhanced_rag_query(
                    query=prompt,
                    selected_files=selected_sources
                )
                answer = response.answer if response else "Nessuna risposta trovata."

                edited_answer = edit_answer(answer).content
                st.markdown(edited_answer)

                assistant_message = {"role": "assistant", "content": edited_answer}
                st.session_state.messages.append(assistant_message)
                st.rerun()

def display_source_document(doc_info: dict, index: int):
    """
    Visualizza le informazioni di un documento di origine in modo pi√π preciso e pulito.
    
    Args:
        doc_info: Dizionario con le informazioni del documento
        index: Indice del documento
    """
    doc_type = doc_info.get("type", "text")
    source = doc_info.get("source", "Sconosciuto")
    page = doc_info.get("page", "N/A")
    
    # Emoji e colori per tipo di documento
    type_info = {
        "text": {"emoji": "üìù", "color": "blue"},
        "image": {"emoji": "üñºÔ∏è", "color": "green"}, 
        "table": {"emoji": "üìä", "color": "orange"}
    }
    
    info = type_info.get(doc_type, {"emoji": "üìÑ", "color": "gray"})
    
    # Header pi√π pulito
    st.markdown(f"""
    <div style="background-color: rgba(0, 123, 255, 0.1); padding: 10px; border-radius: 5px; margin: 5px 0;">
        <strong>{info["emoji"]} Riferimento {index+1}</strong><br>
        üìé <strong>Fonte:</strong> {source}<br>
        üìÑ <strong>Pagina:</strong> {page}<br>
        üè∑Ô∏è <strong>Tipo:</strong> {doc_type.title()}
    </div>
    """, unsafe_allow_html=True)
    
    # Contenuto compatto in expander
    with st.expander("üëÅÔ∏è Visualizza dettagli del documento", expanded=False):
        
        if doc_type == "table":
            # Caption e contesto per tabelle
            caption = doc_info.get("caption")
            context = doc_info.get("context_text")
            
            if caption:
                st.info(f"üìã **Caption:** {caption}")
            
            if context and len(context.strip()) > 0:
                st.text_area("üîç Contesto", context, height=100, disabled=True)
            
            # Contenuto tabella
            table_content = doc_info.get("table_markdown_raw") or doc_info.get("content", "")
            if table_content:
                st.markdown("**üìä Contenuto della tabella:**")
                st.markdown(table_content)
            
        elif doc_type == "image":
            # Caption per immagini
            manual_caption = doc_info.get("manual_caption")
            image_caption = doc_info.get("image_caption")
            context = doc_info.get("context_text")
            
            # Mostra caption in modo pi√π compatto
            captions = []
            if manual_caption and len(manual_caption.strip()) > 0:
                captions.append(f"ÔøΩÔ∏è **Caption manuale:** {manual_caption}")
            if image_caption and len(image_caption.strip()) > 0:
                captions.append(f"ü§ñ **Caption AI:** {image_caption}")
            
            for caption in captions:
                st.markdown(caption)
            
            if context and len(context.strip()) > 0:
                st.text_area("üîç Contesto", context, height=100, disabled=True)
            
            # Immagine
            image_base64 = doc_info.get("image_base64")
            if image_base64:
                try:
                    image_data = base64.b64decode(image_base64)
                    image = Image.open(BytesIO(image_data))
                    st.image(image, caption=f"Immagine da {source} - Pagina {page}", width=300)
                except Exception as e:
                    st.error(f"‚ùå Errore nel caricamento dell'immagine: {e}")
            
        else:  # text
            # Contenuto testuale 
            content = doc_info.get("content", "")
            if len(content) > 300:
                st.text_area("üìù Contenuto (anteprima)", content[:300] + "...", height=150, disabled=True)
                if st.button(f"üìñ Mostra contenuto completo", key=f"show_full_{index}"):
                    st.text_area("üìù Contenuto completo", content, height=300, disabled=True)
            else:
                st.text_area("ÔøΩ Contenuto", content, height=100, disabled=True)
                st.text(context)
            
            # Visualizza la tabella
            st.write("**üìä Contenuto della tabella:**")
            table_content = doc_info.get("table_markdown_raw") or doc_info.get("content", "")
            if table_content:
                st.markdown(table_content)
            
        elif doc_type == "image":
            # Visualizza caption per immagini
            manual_caption = doc_info.get("manual_caption")
            image_caption = doc_info.get("image_caption") 
            
            if manual_caption:
                st.write("**üñºÔ∏è Caption dell'immagine:**")
                st.info(manual_caption)
            
            if image_caption:
                st.write("**ü§ñ Caption generata automaticamente:**")
                st.success(image_caption)
            
            # Visualizza contesto
            context = doc_info.get("context_text")
            if context:
                st.write("**üîç Contesto:**")
                st.text(context)
            
            # Visualizza l'immagine
            image_base64 = doc_info.get("image_base64")
            if image_base64:
                try:
                    image_data = base64.b64decode(image_base64)
                    image = Image.open(BytesIO(image_data))
                    st.image(image, caption=f"Immagine da {source} - Pagina {page}", use_column_width=True)
                except Exception as e:
                    st.error(f"Errore nel caricamento dell'immagine: {e}")
            
        else:  # text
            # Per il testo, mostra solo il contenuto
            st.write("**üìù Contenuto:**")
            content = doc_info.get("content", "")
            if len(content) > 500:
                st.text(content[:500] + "...")
                if st.button(f"Mostra tutto", key=f"show_full_{index}"):
                    st.text(content)
            else:
                st.text(content)

def enhanced_chat_interface_widget(selected_sources: list[str]):
    """
    Interfaccia di chat migliorata che mostra i risultati con caption e contesto
    """
    st.header("ü§ñ Chatta con le Fonti Selezionate")

    if not selected_sources:
        st.warning("‚ö†Ô∏è Seleziona almeno una fonte per avviare la chat.")
        return

    # Logica per creare/caricare la catena RAG
    if st.session_state.get('last_selected_sources') != selected_sources:
        st.session_state.last_selected_sources = selected_sources

    # Inizializzazione e visualizzazione messaggi
    if "messages" not in st.session_state:
        st.session_state.messages = [{"role": "assistant", "content": "Ciao! Fai una domanda sulle fonti selezionate."}]

    # Opzioni avanzate in sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Opzioni di Ricerca")
        show_sources = st.checkbox("Mostra documenti di origine", value=True)
        multimodal = st.checkbox("Ricerca multimodale", value=True, help="Include immagini e tabelle nei risultati")
        include_context = st.checkbox("Include contesto e caption", value=True, help="Mostra caption e testo circostante")

    for msg in st.session_state.messages:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])
            
            # Mostra i documenti di origine se disponibili
            if msg["role"] == "assistant" and "source_docs" in msg and show_sources:
                if msg["source_docs"]:
                    st.markdown("---")
                    st.markdown("**üìö Documenti di origine:**")
                    for i, doc in enumerate(msg["source_docs"]):
                        display_source_document(doc, i)

    # Input utente e risposta del bot
    if prompt := st.chat_input("Fai la tua domanda..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)

        with st.chat_message("assistant"):
            with st.spinner("üîç Sto cercando informazioni..."):
                response = enhanced_rag_query(
                    query=prompt,
                    selected_files=selected_sources,
                    multimodal=multimodal
                )
                answer = response.answer if response else "Nessuna risposta trovata."
                source_docs = response.source_documents if response else []

                edited_answer = edit_answer(answer).content
                st.markdown(edited_answer)

                # Salva il messaggio con i documenti di origine
                assistant_message = {
                    "role": "assistant", 
                    "content": edited_answer,
                    "source_docs": source_docs if show_sources else []
                }
                st.session_state.messages.append(assistant_message)
                
                # Mostra i documenti di origine subito se richiesto
                if show_sources and source_docs:
                    st.markdown("---")
                    st.markdown("**üìö Documenti di origine:**")
                    for i, doc in enumerate(source_docs):
                        display_source_document(doc, i)
                
                st.rerun()